const path = require('path');
const { Compilation, sources } = require('webpack');

/*
class TestHook {
  apply(compiler) {
    compiler.hooks.compilation.tap('TestHook', (compilation) => {
      compilation.hooks.processAssets.tap(
        {
          name: 'MyExampleWebpackPlugin',
          stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
        },
        (assets) => {
          for (let i in assets) {
            const asset = compilation.getAsset(i);
            const content = asset.source.source();
            //compilation.updateAsset(i, new sources.RawSource(content + '(window as any).script = script;'));
            console.log(content);
          }
        }
      );
    });
  }
}
*/
/*
class TestHook2 {
  apply(compiler) {
    compiler.hooks.compilation.tap('TestHook', (compilation) => {
      compilation.hooks.processAssets.tap(
        {
          name: 'MyExampleWebpackPlugin',
          stage: Compilation.PROCESS_ASSETS_STAGE_DERIVED
        },
        (assets) => {
          for (let i in assets) {
            const asset = compilation.getAsset(i);
            const content = asset.source.source();
            //compilation.updateAsset(i, new sources.RawSource(content + '(window as any).script = script;'));
            console.log(content);
          }
        }
      );
    });
  }
}
*/
const config = {
  mode: 'production',
  entry: '{{entryPath}}',
  stats: 'errors-only',
  module: {
    rules: [{
      test: /\.tsx?$/,
      use: [
        {
          loader: 'ts-loader',
          options: {
            configFile: '{{tsConfigPath}}'
          }
        }
      ],
      exclude: /node_modules/
    }]
  },
  output: {
    path: path.resolve('{{outBundleDir}}'),
    filename: '{{outBundleName}}'
  },
  resolve: {
    modules: [
      path.resolve(__dirname, '../')
    ],
    extensions: ['.ts']
  },
  /*
  plugins: [
    new TestHook(),
    new TestHook2()
  ]
  */
}

module.exports = config;
